{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 11497117713699347890,
  "abi": {
    "parameters": [
      {
        "name": "signature",
        "type": {
          "kind": "struct",
          "path": "noir_ring_signatures::sag::Signature",
          "fields": [
            { "name": "c0", "type": { "kind": "field" } },
            {
              "name": "s",
              "type": {
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec",
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": { "kind": "field" }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "hashed_message",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "ring",
        "type": {
          "kind": "struct",
          "path": "std::collections::bounded_vec::BoundedVec",
          "fields": [
            {
              "name": "storage",
              "type": {
                "kind": "array",
                "length": 32,
                "type": {
                  "kind": "struct",
                  "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                  "fields": [
                    { "name": "x", "type": { "kind": "field" } },
                    { "name": "y", "type": { "kind": "field" } },
                    { "name": "is_infinite", "type": { "kind": "boolean" } }
                  ]
                }
              }
            },
            {
              "name": "len",
              "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
            }
          ]
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": { "kind": "boolean" },
      "visibility": "public"
    },
    "error_types": {
      "2763232959425933230": {
        "error_kind": "string",
        "string": "Attempted to write past end of BoundedVec"
      },
      "6485997221020871071": {
        "error_kind": "string",
        "string": "call to assert_max_bit_size"
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "16": {
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n",
      "path": "std/embedded_curve_ops.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
      "path": "std/hash/mod.nr"
    },
    "65": {
      "source": "//! Implementation of the SAG (Signature of Anonymous Group) ring signature scheme\n//! using the Grumpkin curve and Pedersen hash function.\n//!\n//! Ring signatures allow a member of a group to sign a message on behalf of the group\n//! without revealing which member actually created the signature. This provides\n//! anonymity for the signer while still proving that the signature came from a member\n//! of the specified group.\n\nuse std::embedded_curve_ops::{\n    embedded_curve_add, EmbeddedCurvePoint, EmbeddedCurvePoint as Point,\n    EmbeddedCurveScalar as Scalar, fixed_base_scalar_mul, multi_scalar_mul,\n};\n\nuse std::hash::pedersen_hash;\n\n/// Represents a SAG ring signature\n///\n/// # Type Parameters\n/// * `MaxRingSize`: The maximum number of public keys that can be in the ring\npub struct Signature<let MaxRingSize: u32> {\n    /// The initial challenge value c0\n    c0: Field,\n    /// Vector of response values s_i for each ring member\n    s: BoundedVec<Field, MaxRingSize>,\n}\n\n/// Verifies a SAG ring signature\n///\n/// # Arguments\n/// * `signature`: The ring signature to verify\n/// * `hashed_message`: The hash of the message being signed\n/// * `ring`: The set of public keys forming the ring\n///\n/// # Returns\n/// * `true` if the signature is valid, `false` otherwise\n///\n/// # Algorithm Steps\n/// 1. Initialize the challenge vector C with c0\n/// 2. For each public key K_i in the ring:\n///    a. Compute s_iG (scalar multiplication of response s_i with generator G)\n///    b. Compute c_iK_i (scalar multiplication of challenge c_i with public key K_i)\n///    c. Add s_iG and c_iK_i to get a point on the curve\n///    d. Hash the resulting point coordinates with the message to get next challenge\n/// 3. Verify that the final challenge matches the initial c0\npub fn verify<let MaxRingSize: u32>(\n    signature: Signature<MaxRingSize>,\n    hashed_message: Field,\n    ring: BoundedVec<Point, MaxRingSize>,\n) -> bool {\n    // Initialize challenge vector with c0\n    let mut C: BoundedVec<Field, MaxRingSize> = BoundedVec::from_array([0; MaxRingSize]);\n    C.set(0, signature.c0);\n\n    // Process each public key in the ring\n    for i in 0..MaxRingSize {\n        if (i < ring.len()) {\n            // Get the current public key\n            let K = ring.get(i);\n\n            // Convert response s_i to scalar and compute s_iG\n            let s: Scalar = Scalar::from_field(signature.s.get(i));\n            let sG = fixed_base_scalar_mul(s);\n\n            // Convert challenge c_i to scalar and compute c_iK_i\n            let c: Scalar = Scalar::from_field(C.get(i));\n            let cK = multi_scalar_mul([K], [c]);\n\n            // Add s_iG and c_iK_i\n            let sG_cK = embedded_curve_add(sG, cK);\n\n            // Hash the result with the message to get next challenge\n            let hash = pedersen_hash([sG_cK.x, sG_cK.y, hashed_message]);\n\n            // Set the next challenge value\n            C.set((i + 1) % ring.len(), hash);\n        }\n    }\n\n    // Verify the final challenge matches the initial c0\n    C.get(0) == signature.c0\n}\n\n#[test]\nfn test_verify_ring_signature() {\n    let pub_1: Point = Point {\n        x: 0x22c8217d4b526f2c721b32074e7151576aa3a579497c0800134e0a3ece8e7035,\n        y: 0x1e6dc2ce95e96fe93708b56eaa6d2a7d464f95c93e01dc90a47e730442c8cc79,\n        is_infinite: false,\n    };\n\n    let pub_2: Point = Point {\n        x: 0x0bc5b4722e091a1cf7b2f83538dd49eecaab880f94ae4896827db49ed5192338,\n        y: 0x2982b8e604e3aab3aef8c0c734729821dcc0a2e07d6e7143cbd4046e9b9d38be,\n        is_infinite: false,\n    };\n\n    let hashed_message: Field = 0x02a01608cf87d67da4d795a3fdf13d8bbd61892145a973de448fa67f9234dbcf;\n\n    let c0: Field = 0x15245dc24971c6b1f18309594b32d8b46bca105aa3a0420baccda838887a9fae;\n\n    let s: BoundedVec<Field, 2> = BoundedVec::from_array([\n        0x1091edb9186a35a7fe3a63cf56510a75b572be07832e26f071fa7c98da8aa7e7,\n        0x27c73e80fb7996af327ee1cbc6fd9167c5d03e79d8d6f75ad6d1b8923df611c1,\n    ]);\n\n    let signature: Signature<2> = Signature { c0, s };\n    let ring: BoundedVec<EmbeddedCurvePoint, 2> = BoundedVec::from_array([pub_1, pub_2]);\n\n    let res: bool = verify(signature, hashed_message, ring);\n\n    assert(res == true);\n}\n",
      "path": "/Users/envoy1084/nargo/github.com/zkpersona/noir-ring-signatures/v0.1.0/lib/src/sag.nr"
    },
    "70": {
      "source": "use noir_ring_signatures::sag::{Signature, verify};\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\n\npub global MAX_RING_SIZE: u32 = 32;\n\npub fn main(\n    signature: Signature<MAX_RING_SIZE>,\n    hashed_message: Field,\n    ring: BoundedVec<EmbeddedCurvePoint, MAX_RING_SIZE>,\n) -> pub bool {\n    verify(signature, hashed_message, ring)\n}\n",
      "path": "/Users/envoy1084/Projects/Core/ring-forum/crates/sag_32/src/main.nr"
    }
  },
  "names": ["main"],
  "brillig_names": [
    "decompose_hint",
    "lte_hint",
    "directive_integer_quotient",
    "directive_invert"
  ]
}
