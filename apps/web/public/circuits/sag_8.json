{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 322161395606156792,
  "abi": {
    "parameters": [
      {
        "name": "signature",
        "type": {
          "kind": "struct",
          "path": "noir_ring_signatures::sag::Signature",
          "fields": [
            { "name": "c0", "type": { "kind": "field" } },
            {
              "name": "s",
              "type": {
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec",
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 8,
                      "type": { "kind": "field" }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "hashed_message",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "ring",
        "type": {
          "kind": "struct",
          "path": "std::collections::bounded_vec::BoundedVec",
          "fields": [
            {
              "name": "storage",
              "type": {
                "kind": "array",
                "length": 8,
                "type": {
                  "kind": "struct",
                  "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                  "fields": [
                    { "name": "x", "type": { "kind": "field" } },
                    { "name": "y", "type": { "kind": "field" } },
                    { "name": "is_infinite", "type": { "kind": "boolean" } }
                  ]
                }
              }
            },
            {
              "name": "len",
              "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
            }
          ]
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": { "kind": "boolean" },
      "visibility": "public"
    },
    "error_types": {
      "2763232959425933230": {
        "error_kind": "string",
        "string": "Attempted to write past end of BoundedVec"
      },
      "6485997221020871071": {
        "error_kind": "string",
        "string": "call to assert_max_bit_size"
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "16": {
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n",
      "path": "std/embedded_curve_ops.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
      "path": "std/hash/mod.nr"
    },
    "61": {
      "source": "use noir_ring_signatures::sag::{Signature, verify};\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\n\npub global MAX_RING_SIZE: u32 = 8;\n\npub fn main(\n    signature: Signature<MAX_RING_SIZE>,\n    hashed_message: Field,\n    ring: BoundedVec<EmbeddedCurvePoint, MAX_RING_SIZE>,\n) -> pub bool {\n    verify(signature, hashed_message, ring)\n}\n",
      "path": "/Users/envoy1084/Projects/Core/ring-forum/crates/sag_8/src/main.nr"
    },
    "65": {
      "source": "//! Implementation of the SAG (Signature of Anonymous Group) ring signature scheme\n//! using the Grumpkin curve and Pedersen hash function.\n//!\n//! Ring signatures allow a member of a group to sign a message on behalf of the group\n//! without revealing which member actually created the signature. This provides\n//! anonymity for the signer while still proving that the signature came from a member\n//! of the specified group.\n\nuse std::embedded_curve_ops::{\n    embedded_curve_add, EmbeddedCurvePoint, EmbeddedCurvePoint as Point,\n    EmbeddedCurveScalar as Scalar, fixed_base_scalar_mul, multi_scalar_mul,\n};\n\nuse std::hash::pedersen_hash;\n\n/// Represents a SAG ring signature\n///\n/// # Type Parameters\n/// * `MaxRingSize`: The maximum number of public keys that can be in the ring\npub struct Signature<let MaxRingSize: u32> {\n    /// The initial challenge value c0\n    c0: Field,\n    /// Vector of response values s_i for each ring member\n    s: BoundedVec<Field, MaxRingSize>,\n}\n\n/// Verifies a SAG ring signature\n///\n/// # Arguments\n/// * `signature`: The ring signature to verify\n/// * `hashed_message`: The hash of the message being signed\n/// * `ring`: The set of public keys forming the ring\n///\n/// # Returns\n/// * `true` if the signature is valid, `false` otherwise\n///\n/// # Algorithm Steps\n/// 1. Initialize the challenge vector C with c0\n/// 2. For each public key K_i in the ring:\n///    a. Compute s_iG (scalar multiplication of response s_i with generator G)\n///    b. Compute c_iK_i (scalar multiplication of challenge c_i with public key K_i)\n///    c. Add s_iG and c_iK_i to get a point on the curve\n///    d. Hash the resulting point coordinates with the message to get next challenge\n/// 3. Verify that the final challenge matches the initial c0\npub fn verify<let MaxRingSize: u32>(\n    signature: Signature<MaxRingSize>,\n    hashed_message: Field,\n    ring: BoundedVec<Point, MaxRingSize>,\n) -> bool {\n    // Initialize challenge vector with c0\n    let mut C: BoundedVec<Field, MaxRingSize> = BoundedVec::from_array([0; MaxRingSize]);\n    C.set(0, signature.c0);\n\n    // Process each public key in the ring\n    for i in 0..MaxRingSize {\n        if (i < ring.len()) {\n            // Get the current public key\n            let K = ring.get(i);\n\n            // Convert response s_i to scalar and compute s_iG\n            let s: Scalar = Scalar::from_field(signature.s.get(i));\n            let sG = fixed_base_scalar_mul(s);\n\n            // Convert challenge c_i to scalar and compute c_iK_i\n            let c: Scalar = Scalar::from_field(C.get(i));\n            let cK = multi_scalar_mul([K], [c]);\n\n            // Add s_iG and c_iK_i\n            let sG_cK = embedded_curve_add(sG, cK);\n\n            // Hash the result with the message to get next challenge\n            let hash = pedersen_hash([sG_cK.x, sG_cK.y, hashed_message]);\n\n            // Set the next challenge value\n            C.set((i + 1) % ring.len(), hash);\n        }\n    }\n\n    // Verify the final challenge matches the initial c0\n    C.get(0) == signature.c0\n}\n\n#[test]\nfn test_verify_ring_signature() {\n    let pub_1: Point = Point {\n        x: 0x22c8217d4b526f2c721b32074e7151576aa3a579497c0800134e0a3ece8e7035,\n        y: 0x1e6dc2ce95e96fe93708b56eaa6d2a7d464f95c93e01dc90a47e730442c8cc79,\n        is_infinite: false,\n    };\n\n    let pub_2: Point = Point {\n        x: 0x0bc5b4722e091a1cf7b2f83538dd49eecaab880f94ae4896827db49ed5192338,\n        y: 0x2982b8e604e3aab3aef8c0c734729821dcc0a2e07d6e7143cbd4046e9b9d38be,\n        is_infinite: false,\n    };\n\n    let hashed_message: Field = 0x02a01608cf87d67da4d795a3fdf13d8bbd61892145a973de448fa67f9234dbcf;\n\n    let c0: Field = 0x15245dc24971c6b1f18309594b32d8b46bca105aa3a0420baccda838887a9fae;\n\n    let s: BoundedVec<Field, 2> = BoundedVec::from_array([\n        0x1091edb9186a35a7fe3a63cf56510a75b572be07832e26f071fa7c98da8aa7e7,\n        0x27c73e80fb7996af327ee1cbc6fd9167c5d03e79d8d6f75ad6d1b8923df611c1,\n    ]);\n\n    let signature: Signature<2> = Signature { c0, s };\n    let ring: BoundedVec<EmbeddedCurvePoint, 2> = BoundedVec::from_array([pub_1, pub_2]);\n\n    let res: bool = verify(signature, hashed_message, ring);\n\n    assert(res == true);\n}\n",
      "path": "/Users/envoy1084/nargo/github.com/zkpersona/noir-ring-signatures/v0.1.0/lib/src/sag.nr"
    }
  },
  "names": ["main"],
  "brillig_names": [
    "decompose_hint",
    "lte_hint",
    "directive_integer_quotient",
    "directive_invert"
  ]
}
