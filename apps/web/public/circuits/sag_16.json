{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 6508105309507002017,
  "abi": {
    "parameters": [
      {
        "name": "signature",
        "type": {
          "kind": "struct",
          "path": "noir_ring_signatures::sag::Signature",
          "fields": [
            { "name": "c0", "type": { "kind": "field" } },
            {
              "name": "s",
              "type": {
                "kind": "struct",
                "path": "std::collections::bounded_vec::BoundedVec",
                "fields": [
                  {
                    "name": "storage",
                    "type": {
                      "kind": "array",
                      "length": 16,
                      "type": { "kind": "field" }
                    }
                  },
                  {
                    "name": "len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "hashed_message",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "ring",
        "type": {
          "kind": "struct",
          "path": "std::collections::bounded_vec::BoundedVec",
          "fields": [
            {
              "name": "storage",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "struct",
                  "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                  "fields": [
                    { "name": "x", "type": { "kind": "field" } },
                    { "name": "y", "type": { "kind": "field" } },
                    { "name": "is_infinite", "type": { "kind": "boolean" } }
                  ]
                }
              }
            },
            {
              "name": "len",
              "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
            }
          ]
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": { "kind": "boolean" },
      "visibility": "public"
    },
    "error_types": {
      "2763232959425933230": {
        "error_kind": "string",
        "string": "Attempted to write past end of BoundedVec"
      },
      "6485997221020871071": {
        "error_kind": "string",
        "string": "call to assert_max_bit_size"
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "16": {
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n",
      "path": "std/embedded_curve_ops.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
      "path": "std/hash/mod.nr"
    },
    "65": {
      "source": "//! Implementation of the SAG (Signature of Anonymous Group) ring signature scheme\n//! using the Grumpkin curve and Pedersen hash function.\n//!\n//! Ring signatures allow a member of a group to sign a message on behalf of the group\n//! without revealing which member actually created the signature. This provides\n//! anonymity for the signer while still proving that the signature came from a member\n//! of the specified group.\n\nuse std::embedded_curve_ops::{\n    embedded_curve_add, EmbeddedCurvePoint, EmbeddedCurvePoint as Point,\n    EmbeddedCurveScalar as Scalar, fixed_base_scalar_mul, multi_scalar_mul,\n};\n\nuse std::hash::pedersen_hash;\n\n/// Represents a SAG ring signature\n///\n/// # Type Parameters\n/// * `MaxRingSize`: The maximum number of public keys that can be in the ring\npub struct Signature<let MaxRingSize: u32> {\n    /// The initial challenge value c0\n    c0: Field,\n    /// Vector of response values s_i for each ring member\n    s: BoundedVec<Field, MaxRingSize>,\n}\n\n/// Verifies a SAG ring signature\n///\n/// # Arguments\n/// * `signature`: The ring signature to verify\n/// * `hashed_message`: The hash of the message being signed\n/// * `ring`: The set of public keys forming the ring\n///\n/// # Returns\n/// * `true` if the signature is valid, `false` otherwise\n///\n/// # Algorithm Steps\n/// 1. Initialize the challenge vector C with c0\n/// 2. For each public key K_i in the ring:\n///    a. Compute s_iG (scalar multiplication of response s_i with generator G)\n///    b. Compute c_iK_i (scalar multiplication of challenge c_i with public key K_i)\n///    c. Add s_iG and c_iK_i to get a point on the curve\n///    d. Hash the resulting point coordinates with the message to get next challenge\n/// 3. Verify that the final challenge matches the initial c0\npub fn verify<let MaxRingSize: u32>(\n    signature: Signature<MaxRingSize>,\n    hashed_message: Field,\n    ring: BoundedVec<Point, MaxRingSize>,\n) -> bool {\n    // Initialize challenge vector with c0\n    let mut C: BoundedVec<Field, MaxRingSize> = BoundedVec::from_array([0; MaxRingSize]);\n    C.set(0, signature.c0);\n\n    // Process each public key in the ring\n    for i in 0..MaxRingSize {\n        if (i < ring.len()) {\n            // Get the current public key\n            let K = ring.get(i);\n\n            // Convert response s_i to scalar and compute s_iG\n            let s: Scalar = Scalar::from_field(signature.s.get(i));\n            let sG = fixed_base_scalar_mul(s);\n\n            // Convert challenge c_i to scalar and compute c_iK_i\n            let c: Scalar = Scalar::from_field(C.get(i));\n            let cK = multi_scalar_mul([K], [c]);\n\n            // Add s_iG and c_iK_i\n            let sG_cK = embedded_curve_add(sG, cK);\n\n            // Hash the result with the message to get next challenge\n            let hash = pedersen_hash([sG_cK.x, sG_cK.y, hashed_message]);\n\n            // Set the next challenge value\n            C.set((i + 1) % ring.len(), hash);\n        }\n    }\n\n    // Verify the final challenge matches the initial c0\n    C.get(0) == signature.c0\n}\n\n#[test]\nfn test_verify_ring_signature() {\n    let pub_1: Point = Point {\n        x: 0x22c8217d4b526f2c721b32074e7151576aa3a579497c0800134e0a3ece8e7035,\n        y: 0x1e6dc2ce95e96fe93708b56eaa6d2a7d464f95c93e01dc90a47e730442c8cc79,\n        is_infinite: false,\n    };\n\n    let pub_2: Point = Point {\n        x: 0x0bc5b4722e091a1cf7b2f83538dd49eecaab880f94ae4896827db49ed5192338,\n        y: 0x2982b8e604e3aab3aef8c0c734729821dcc0a2e07d6e7143cbd4046e9b9d38be,\n        is_infinite: false,\n    };\n\n    let hashed_message: Field = 0x02a01608cf87d67da4d795a3fdf13d8bbd61892145a973de448fa67f9234dbcf;\n\n    let c0: Field = 0x15245dc24971c6b1f18309594b32d8b46bca105aa3a0420baccda838887a9fae;\n\n    let s: BoundedVec<Field, 2> = BoundedVec::from_array([\n        0x1091edb9186a35a7fe3a63cf56510a75b572be07832e26f071fa7c98da8aa7e7,\n        0x27c73e80fb7996af327ee1cbc6fd9167c5d03e79d8d6f75ad6d1b8923df611c1,\n    ]);\n\n    let signature: Signature<2> = Signature { c0, s };\n    let ring: BoundedVec<EmbeddedCurvePoint, 2> = BoundedVec::from_array([pub_1, pub_2]);\n\n    let res: bool = verify(signature, hashed_message, ring);\n\n    assert(res == true);\n}\n",
      "path": "/Users/envoy1084/nargo/github.com/zkpersona/noir-ring-signatures/v0.1.0/lib/src/sag.nr"
    },
    "69": {
      "source": "use noir_ring_signatures::sag::{Signature, verify};\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\n\npub global MAX_RING_SIZE: u32 = 16;\n\npub fn main(\n    signature: Signature<MAX_RING_SIZE>,\n    hashed_message: Field,\n    ring: BoundedVec<EmbeddedCurvePoint, MAX_RING_SIZE>,\n) -> pub bool {\n    verify(signature, hashed_message, ring)\n}\n",
      "path": "/Users/envoy1084/Projects/Core/ring-forum/crates/sag_16/src/main.nr"
    }
  },
  "names": ["main"],
  "brillig_names": [
    "decompose_hint",
    "lte_hint",
    "directive_integer_quotient",
    "directive_invert"
  ]
}
